{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FalconLink Extensions Documentation Visit Getting Started for a detailed explanation on creating an extension. Join Our Discord to report any bugs or feature requests. FalconLink Extensions makes it really easy to add stuff to the proxy. Here is an example manifest.json: { \"version\": \"1\", \"icon\": \"icon.png\", \"id\": 123, \"name\": \"Cool Extension\", \"images\": [ \"image1.png\", \"image2.png\", \"image3.png\" ], \"script\": \"index.js\" } In this manifest.json, the index.js script will be run. Index.js can access a extension API that allows it to inject content scripts, manage tabs, and more! Here is a basic index.js script that will inject an adblocker: async function injectAdBlocker() { const script = await API.getSrcFor(\"adblocker.js\"); const tabs = await API.getAllTabs(); for (var i = 0; i < await tabs.length; i++) { if (!(await API.isScriptInjected(await script, await tabs[i].id))) { API.injectScript(await script, await tabs[i].id); } } } setInterval(injectAdBlocker, 1000); Content scripts that are injected can also communicate with the main script through message channels. Here is how you can send a message in a content script: const channel123 = new ExtensionMessageChannel(); channel123.sendMessage(\"testing123\"); Then you can use this code to recieve the message in your main script: API.onMessageChannelCreate = (channel) => { channel.onMessage = (message) => { alert(\"We have a message!!!: \" + message); }; }","title":"Home"},{"location":"#falconlink-extensions-documentation","text":"","title":"FalconLink Extensions Documentation"},{"location":"#visit-getting-started-for-a-detailed-explanation-on-creating-an-extension","text":"","title":"Visit Getting Started for a detailed explanation on creating an extension."},{"location":"#join-our-discord-to-report-any-bugs-or-feature-requests","text":"FalconLink Extensions makes it really easy to add stuff to the proxy. Here is an example manifest.json: { \"version\": \"1\", \"icon\": \"icon.png\", \"id\": 123, \"name\": \"Cool Extension\", \"images\": [ \"image1.png\", \"image2.png\", \"image3.png\" ], \"script\": \"index.js\" } In this manifest.json, the index.js script will be run. Index.js can access a extension API that allows it to inject content scripts, manage tabs, and more! Here is a basic index.js script that will inject an adblocker: async function injectAdBlocker() { const script = await API.getSrcFor(\"adblocker.js\"); const tabs = await API.getAllTabs(); for (var i = 0; i < await tabs.length; i++) { if (!(await API.isScriptInjected(await script, await tabs[i].id))) { API.injectScript(await script, await tabs[i].id); } } } setInterval(injectAdBlocker, 1000); Content scripts that are injected can also communicate with the main script through message channels. Here is how you can send a message in a content script: const channel123 = new ExtensionMessageChannel(); channel123.sendMessage(\"testing123\"); Then you can use this code to recieve the message in your main script: API.onMessageChannelCreate = (channel) => { channel.onMessage = (message) => { alert(\"We have a message!!!: \" + message); }; }","title":"Join Our Discord to report any bugs or feature requests."},{"location":"docs/","text":"FalconLink Extensions Documentation Interacting with the API In the main script, you can access the API via the API object. This object will contain all the functions you need to interact with the proxy. Pay close attention to how each API function is used, most of the functions are asynchronous meaning you have to use \"await\". Tab objects The API has multiple functions that return Tab objects. Here is the structure of a Tab Object: { \"url\": \"https://google.com\", //Current URL of the tab \"title\": \"Google Search\", //Current title of the tab \"id\": \"123321\" //Unique ID assigned to every proxy tab } Here are the API functions that return tab objects (Note that all of them are asynchronous): await API.getCurrentTab() Arguments: None Return value: Tab Object This function will return a promise that resolves to the tab object of the tab the user is currently on. await API.getAllTabs() Arguments: None Return value: Array of Tab Objects This function will return a promise that resolves to an array of all the tab objects. await API.getTabByID(id) Arguments: ID Return value: Tab Object This function will return a promise that resolves to the tab object of the tab ID given. Injecting Scripts await API.injectScript(script, tabID, inline) Arguments: Script, TabID, Inline (optional, defaults to false) Script is either a URL to a javascript file or javascript code. If it is javascript code, the inline argument must be set to true, if not the inline argument is not neccesary. TabID is the ID of the tab you want to inject this script into. NOTE: If using a JavaScript file that is part of your extensions source code, you can use the API.getSrcFor function to generate a URL for the file. Return value: Boolean Will return true if the script was successfully injected. This function will inject a script element in the end of the tabs body. It returns a promise that resolves to true if the injection was successful. await API.isScriptInjected(script, tabID, inline) Arguments: Script, TabID, Inline (optional, defaults to false) Script is either a URL to a javascript file or javascript code. If it is javascript code, the inline argument must be set to true, if not the inline argument is not neccesary. TabID is the ID of the tab you want to inject this script into. NOTE: If using a JavaScript file that is part of your extensions source code, you can use the API.getSrcFor function to generate a URL for the file. Return value: Boolean Will return true if the script is injected or false if it is not. This function will check if the provided script has already been injected. It returns a promise that resolves to a boolean. Misc. Functions await API.getSrcFor(Path) Arguments: Path Return value: URL This function takes a file path (ex: \"/scripts/content_script.js\") that is relative to your extension and returns a promise that resolves to a URL that that file can be accessed at. This is usefull for things like opening an extension page or injecting a script. await API.getWindowByID(ID) Arguments: ID Return value: Window This function takes a Tab ID and returns a promise that resolves to the window object of that tab. await API.createTab(url, proxy) Arguments: URL, Proxy (Optional, defaults to true) URL is the URL of the page you want to open. Proxy is a boolean that specifies if you want the page to be proxied. In most cases, this should be left at true. Return value: Tab ID This function takes the URL of the page you want to open and if you want it proxied or not, and returns a promise that resolves to the Tab ID of the new tab. Messaging Messaging allows communication between the main script, and content scripts. Messaging Channels are created by the content scripts, and once made can have messages sent both ways. Creating a Message Channel To create a message channel, create a new instance of the ExtensionMessageChannel class inside of a content script. const myMessageChannel = new ExtensionMessageChannel(); IMPORTANT: Message Channels can only be created in injected content scripts. If you create a message channel in for example, a buttons onclick attribute, it will not work. This will create a channel. Now to recieve messages that are sent in a channel inside the main script, set API.onMessageChannelCreate //Show any messages recieved to the user. API.onMessageChannelCreate = (channel) => { channel.onMessage = (message) => { alert(\"We have a message!!!: \" + message); }; } Now you can send messages. content_script.js: myMessageChannel.sendMessage(\"testing123\"); And it should make a popup box saying \"We have a message!!!: testing123\" appear. Extension Icon Clicked When the extension icon is clicked, the API.onIconClicked function will be run. You can use something like this to execute code when the icon is clicked: API.onIconClicked = () => { alert(\"Extension icon clicked!\"); }","title":"Docs"},{"location":"docs/#falconlink-extensions-documentation","text":"","title":"FalconLink Extensions Documentation"},{"location":"docs/#interacting-with-the-api","text":"In the main script, you can access the API via the API object. This object will contain all the functions you need to interact with the proxy. Pay close attention to how each API function is used, most of the functions are asynchronous meaning you have to use \"await\".","title":"Interacting with the API"},{"location":"docs/#tab-objects","text":"The API has multiple functions that return Tab objects. Here is the structure of a Tab Object: { \"url\": \"https://google.com\", //Current URL of the tab \"title\": \"Google Search\", //Current title of the tab \"id\": \"123321\" //Unique ID assigned to every proxy tab } Here are the API functions that return tab objects (Note that all of them are asynchronous):","title":"Tab objects"},{"location":"docs/#await-apigetcurrenttab","text":"","title":"await API.getCurrentTab()"},{"location":"docs/#arguments-none","text":"","title":"Arguments: None"},{"location":"docs/#return-value-tab-object","text":"This function will return a promise that resolves to the tab object of the tab the user is currently on.","title":"Return value: Tab Object"},{"location":"docs/#await-apigetalltabs","text":"","title":"await API.getAllTabs()"},{"location":"docs/#arguments-none_1","text":"","title":"Arguments: None"},{"location":"docs/#return-value-array-of-tab-objects","text":"This function will return a promise that resolves to an array of all the tab objects.","title":"Return value: Array of Tab Objects"},{"location":"docs/#await-apigettabbyidid","text":"","title":"await API.getTabByID(id)"},{"location":"docs/#arguments-id","text":"","title":"Arguments: ID"},{"location":"docs/#return-value-tab-object_1","text":"This function will return a promise that resolves to the tab object of the tab ID given.","title":"Return value: Tab Object"},{"location":"docs/#injecting-scripts","text":"","title":"Injecting Scripts"},{"location":"docs/#await-apiinjectscriptscript-tabid-inline","text":"","title":"await API.injectScript(script, tabID, inline)"},{"location":"docs/#arguments-script-tabid-inline-optional-defaults-to-false","text":"Script is either a URL to a javascript file or javascript code. If it is javascript code, the inline argument must be set to true, if not the inline argument is not neccesary. TabID is the ID of the tab you want to inject this script into. NOTE: If using a JavaScript file that is part of your extensions source code, you can use the API.getSrcFor function to generate a URL for the file.","title":"Arguments: Script, TabID, Inline (optional, defaults to false)"},{"location":"docs/#return-value-boolean","text":"Will return true if the script was successfully injected. This function will inject a script element in the end of the tabs body. It returns a promise that resolves to true if the injection was successful.","title":"Return value: Boolean"},{"location":"docs/#await-apiisscriptinjectedscript-tabid-inline","text":"","title":"await API.isScriptInjected(script, tabID, inline)"},{"location":"docs/#arguments-script-tabid-inline-optional-defaults-to-false_1","text":"Script is either a URL to a javascript file or javascript code. If it is javascript code, the inline argument must be set to true, if not the inline argument is not neccesary. TabID is the ID of the tab you want to inject this script into. NOTE: If using a JavaScript file that is part of your extensions source code, you can use the API.getSrcFor function to generate a URL for the file.","title":"Arguments: Script, TabID, Inline (optional, defaults to false)"},{"location":"docs/#return-value-boolean_1","text":"Will return true if the script is injected or false if it is not. This function will check if the provided script has already been injected. It returns a promise that resolves to a boolean.","title":"Return value: Boolean"},{"location":"docs/#misc-functions","text":"","title":"Misc. Functions"},{"location":"docs/#await-apigetsrcforpath","text":"","title":"await API.getSrcFor(Path)"},{"location":"docs/#arguments-path","text":"","title":"Arguments: Path"},{"location":"docs/#return-value-url","text":"This function takes a file path (ex: \"/scripts/content_script.js\") that is relative to your extension and returns a promise that resolves to a URL that that file can be accessed at. This is usefull for things like opening an extension page or injecting a script.","title":"Return value: URL"},{"location":"docs/#await-apigetwindowbyidid","text":"","title":"await API.getWindowByID(ID)"},{"location":"docs/#arguments-id_1","text":"","title":"Arguments: ID"},{"location":"docs/#return-value-window","text":"This function takes a Tab ID and returns a promise that resolves to the window object of that tab.","title":"Return value: Window"},{"location":"docs/#await-apicreatetaburl-proxy","text":"","title":"await API.createTab(url, proxy)"},{"location":"docs/#arguments-url-proxy-optional-defaults-to-true","text":"URL is the URL of the page you want to open. Proxy is a boolean that specifies if you want the page to be proxied. In most cases, this should be left at true.","title":"Arguments: URL, Proxy (Optional, defaults to true)"},{"location":"docs/#return-value-tab-id","text":"This function takes the URL of the page you want to open and if you want it proxied or not, and returns a promise that resolves to the Tab ID of the new tab.","title":"Return value: Tab ID"},{"location":"docs/#messaging","text":"Messaging allows communication between the main script, and content scripts. Messaging Channels are created by the content scripts, and once made can have messages sent both ways.","title":"Messaging"},{"location":"docs/#creating-a-message-channel","text":"To create a message channel, create a new instance of the ExtensionMessageChannel class inside of a content script. const myMessageChannel = new ExtensionMessageChannel();","title":"Creating a Message Channel"},{"location":"docs/#important-message-channels-can-only-be-created-in-injected-content-scripts-if-you-create-a-message-channel-in-for-example-a-buttons-onclick-attribute-it-will-not-work","text":"This will create a channel. Now to recieve messages that are sent in a channel inside the main script, set API.onMessageChannelCreate //Show any messages recieved to the user. API.onMessageChannelCreate = (channel) => { channel.onMessage = (message) => { alert(\"We have a message!!!: \" + message); }; } Now you can send messages. content_script.js: myMessageChannel.sendMessage(\"testing123\"); And it should make a popup box saying \"We have a message!!!: testing123\" appear.","title":"IMPORTANT: Message Channels can only be created in injected content scripts. If you create a message channel in for example, a buttons onclick attribute, it will not work."},{"location":"docs/#extension-icon-clicked","text":"When the extension icon is clicked, the API.onIconClicked function will be run. You can use something like this to execute code when the icon is clicked: API.onIconClicked = () => { alert(\"Extension icon clicked!\"); }","title":"Extension Icon Clicked"},{"location":"gettingstarted/","text":"How to start developing a FalconLink Extension Installation Make sure you have NodeJS and NPM installed. apt install npm nodejs Clone the FalconLink repo . git clone https://github.com/Falconlink/FalconLink Go to the FalconLink directory cd FalconLink Install Packages npm i Development Now you are ready to start developing your extension Click the button below to generate an ID for your extension. Generate ID Next, Go to the directory public/static/extensions using your IDE of choice. Create a new folder named the extension ID you were just given. Inside that folder create two files, index.js and manifest.json. Put this inside your manifest.json, replacing it with your values: { \"version\": \"1\", //Once we update the library, we will use this to know what version to run an extension with, ensuring backwards compatability. Currently version 1 is newest \"id\": 0, //ID for your extension \"name\": \"Extension Name\", //I am making a extension that spins your tabs around :P \"script\": \"index.js\", //The main script that is run in your extension \"images\": [], //List of images for the extension store page \"icon\": \"about:blank\" //Icon for the extension, if none, put about:blank } Inside you index.js file you can put the code for your extension, you can also interact with the proxy's browser using the API commands detailed in the Docs page. For now I will just alert the users that the extension has been started: alert(\"Extension Started!\"); Running the extension To test out your extension, start the server by running npm start This will start a server on port 8080 - Now, go to 127.0.0.1:8080 in your browser Next, open the dev console and type in new Extension(extensionID) //Replace extensionID with the ID of your extension Make sure that you replace extensionID with your extensions ID. You should see a alert box that says \"Extension Started!\" If not Join Our Discord for help Submitting your extension Create a pull request on the FalconLink GitHub Repo . Also it may help to join our discord and tell us about the extension, as we don't check the github repo very often.","title":"Getting Started"},{"location":"gettingstarted/#how-to-start-developing-a-falconlink-extension","text":"","title":"How to start developing a FalconLink Extension"},{"location":"gettingstarted/#installation","text":"Make sure you have NodeJS and NPM installed. apt install npm nodejs Clone the FalconLink repo . git clone https://github.com/Falconlink/FalconLink Go to the FalconLink directory cd FalconLink Install Packages npm i","title":"Installation"},{"location":"gettingstarted/#development","text":"","title":"Development"},{"location":"gettingstarted/#now-you-are-ready-to-start-developing-your-extension","text":"Click the button below to generate an ID for your extension. Generate ID Next, Go to the directory public/static/extensions using your IDE of choice. Create a new folder named the extension ID you were just given. Inside that folder create two files, index.js and manifest.json. Put this inside your manifest.json, replacing it with your values: { \"version\": \"1\", //Once we update the library, we will use this to know what version to run an extension with, ensuring backwards compatability. Currently version 1 is newest \"id\": 0, //ID for your extension \"name\": \"Extension Name\", //I am making a extension that spins your tabs around :P \"script\": \"index.js\", //The main script that is run in your extension \"images\": [], //List of images for the extension store page \"icon\": \"about:blank\" //Icon for the extension, if none, put about:blank } Inside you index.js file you can put the code for your extension, you can also interact with the proxy's browser using the API commands detailed in the Docs page. For now I will just alert the users that the extension has been started: alert(\"Extension Started!\");","title":"Now you are ready to start developing your extension"},{"location":"gettingstarted/#running-the-extension","text":"To test out your extension, start the server by running npm start This will start a server on port 8080 - Now, go to 127.0.0.1:8080 in your browser Next, open the dev console and type in new Extension(extensionID) //Replace extensionID with the ID of your extension Make sure that you replace extensionID with your extensions ID. You should see a alert box that says \"Extension Started!\" If not Join Our Discord for help","title":"Running the extension"},{"location":"gettingstarted/#submitting-your-extension","text":"Create a pull request on the FalconLink GitHub Repo . Also it may help to join our discord and tell us about the extension, as we don't check the github repo very often.","title":"Submitting your extension"}]}